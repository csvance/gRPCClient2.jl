var documenterSearchIndex = {"docs":
[{"location":"#gRPCClient2.jl","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"gRPCClient2.jl aims to be a production grade gRPC client emphasizing performance and reliability.","category":"page"},{"location":"#Features","page":"gRPCClient2.jl","title":"Features","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"Unary RPC (non streaming)\nHTTP/2 connection multiplexing\nSynchronous and asynchronous interfaces\nThread safe\nSSL/TLS","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"The client is missing a few features which will be added over time:","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"OAuth2\nCompression\nStreaming RPC","category":"page"},{"location":"#Getting-Started","page":"gRPCClient2.jl","title":"Getting Started","text":"","category":"section"},{"location":"#Test-gRPC-Server","page":"gRPCClient2.jl","title":"Test gRPC Server","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"All examples in the documentation are run against a test server written in Python. You can run it by doing the following:","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"# Install uv package manager - see https://docs.astral.sh/uv/#installation for more details\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Change directory to the python test server project\ncd test/python\n\n# Run the test server\nuv run grpc_test_server.py\n","category":"page"},{"location":"#Code-Generation","page":"gRPCClient2.jl","title":"Code Generation","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"Note: this is currently disabled due to blocking issues in ProtoBuf.jl. See here for more information.","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"gRPCClient2.jl integrates with ProtoBuf.jl to automatically generate Julia client stubs for calling gRPC. ","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"using ProtoBuf\nusing gRPCClient2\n\n# Creates Julia bindings for the messages and RPC defined in test.proto\nprotojl(\"test/proto/test.proto\", \".\", \"test/gen\")","category":"page"},{"location":"#Making-Requests-with-gRPCClient2.jl","page":"gRPCClient2.jl","title":"Making Requests with gRPCClient2.jl","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"using gRPCClient2\n\n# Include the generated bindings\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Create a client bound to a specific RPC\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# Make a syncronous request and get back a TestResponse\nresponse = grpc_sync_request(client, TestRequest(1, zeros(UInt64, 1)))\n@info response\n\n# Make some async requests and await their TestResponse\nrequests = Vector{gRPCRequest}()\nfor i in 1:10\n    push!(\n        requests, \n        grpc_async_request(client, TestRequest(1, zeros(UInt64, 1)))\n    )\nend\n\nfor request in requests\n    response = grpc_async_await(client, request)\n    @info response\nend","category":"page"},{"location":"#Exceptions","page":"gRPCClient2.jl","title":"Exceptions","text":"","category":"section"},{"location":"#gRPCClient2.gRPCServiceCallException","page":"gRPCClient2.jl","title":"gRPCClient2.gRPCServiceCallException","text":"Exception type that is thrown when something goes wrong while calling an RPC. This can either be triggered by the servers response code or by the client when something fails.\n\nThis exception type has two fields:\n\nmessage::String\ngrpc_status::Int - See here for an indepth explanation of each status.\n\n\n\n\n\n","category":"type"},{"location":"#Package-Initialization-/-Shutdown","page":"gRPCClient2.jl","title":"Package Initialization / Shutdown","text":"","category":"section"},{"location":"#gRPCClient2.grpc_init-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_init","text":"grpc_init()\n\nInitializes the global gRPCCURL state. This should be called once before making gRPC calls. There is no harm in calling this more than once (ie by different packages/dependencies)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_shutdown-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_shutdown","text":"grpc_shutdown()\n\nShuts down the global gRPCCURL state. This neatly cleans up all active connections and requests. Useful for calling during development with Revise.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_global_handle-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_global_handle","text":"grpc_global_handle()\n\nReturns the global gRPCCURL state which contains a libCURL multi handle. By default all gRPC functions use this multi in order to ensure that HTTP/2 multiplexing happens where possible.\n\n\n\n\n\n","category":"method"},{"location":"#Request-Functions","page":"gRPCClient2.jl","title":"Request Functions","text":"","category":"section"},{"location":"#gRPCClient2.grpc_sync_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, TResponse}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_sync_request","text":"grpc_sync_request(client::gRPCClient{TRequest,TResponse}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nDo a synchronous gRPC request: send the request and wait for the response before returning it.  Under the hood this just calls grpc_async_request and grpc_async_await\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, TResponse}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,TResponse}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return a gRPCRequest object without waiting for the response.  In order to wait on / retrieve the result once its ready, call grpc_async_await. This is ideal when you need to send many requests in parallel and waiting on each response before sending the next request would things down.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, TResponse}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_await","text":"grpc_async_await(client::gRPCClient{TRequest,TResponse}, request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nWait for the request to complete and return the response when it is ready. Throws any exceptions that were encountered during handling of the request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, TResponse}, TRequest, Channel{gRPCAsyncChannelResponse{TResponse}}, Int64}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,TResponse}, request::TRequest, channel::Channel{gRPCAsyncChannelResponse{TResponse}}, index::Int64) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return. When the request is complete a background task will put the response in the provided channel. This has the advantage over the request / await patern in that you can handle responses immediately after they are recieved in any order.\n\nusing gRPCClient2\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Connect to the test server\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\nN = 10\n\nchannel = Channel{gRPCAsyncChannelResponse{TestResponse}}(N)\n\nfor (index, request) in enumerate([TestRequest(i, zeros(UInt64, i)) for i in 1:N])\n     grpc_async_request(client, request, channel, index)\nend\n\nfor i in 1:N\n    cr = take!(channel)\n    # Check if an exception was thrown, if so throw it here\n    !isnothing(cr.ex) && throw(cr.ex)\n\n    # If this does not hold true, then the requests and responses have gotten mixed up.\n    @assert length(cr.response.data) == cr.index\nend\n\n\n\n\n\n\n","category":"method"}]
}
