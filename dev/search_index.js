var documenterSearchIndex = {"docs":
[{"location":"#gRPCClient2.jl","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"gRPCClient2.jl aims to be a production grade gRPC client emphasizing performance and reliability.","category":"page"},{"location":"#Features","page":"gRPCClient2.jl","title":"Features","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"Unary+Streaming RPC\nHTTP/2 connection multiplexing\nSynchronous and asynchronous interfaces\nThread safe\nSSL/TLS","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"The client is missing a few features which will be added over time:","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"OAuth2\nCompression","category":"page"},{"location":"#Getting-Started","page":"gRPCClient2.jl","title":"Getting Started","text":"","category":"section"},{"location":"#Test-gRPC-Server","page":"gRPCClient2.jl","title":"Test gRPC Server","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"All examples in the documentation are run against a test server written in Python. You can run it by doing the following:","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"# Install uv package manager - see https://docs.astral.sh/uv/#installation for more details\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Change directory to the python test server project\ncd test/python\n\n# Run the test server\nuv run grpc_test_server.py\n","category":"page"},{"location":"#Code-Generation","page":"gRPCClient2.jl","title":"Code Generation","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"Note: support for this is currently being upstreaming into ProtoBuf.jl. Until then, make sure you add the development branch which supports code generation:","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"pkg> add https://github.com/csvance/ProtoBuf.jl.git#1727adbc3a7d95f91ef23addb1d04e2b49d0647c","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"gRPCClient2.jl integrates with ProtoBuf.jl to automatically generate Julia client stubs for calling gRPC. ","category":"page"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"using ProtoBuf\nusing gRPCClient2\n\n# Register our service codegen with ProtoBuf.jl\ngrpc_register_service_codegen()\n\n# Creates Julia bindings for the messages and RPC defined in test.proto\nprotojl(\"test/proto/test.proto\", \".\", \"test/gen\")","category":"page"},{"location":"#Example-Usage","page":"gRPCClient2.jl","title":"Example Usage","text":"","category":"section"},{"location":"","page":"gRPCClient2.jl","title":"gRPCClient2.jl","text":"See here for examples covering all provided interfaces for both unary and streaming gRPC calls. ","category":"page"},{"location":"#Package-Initialization-/-Shutdown","page":"gRPCClient2.jl","title":"Package Initialization / Shutdown","text":"","category":"section"},{"location":"#gRPCClient2.grpc_init-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_init","text":"grpc_init([grpc_curl::gRPCCURL])\n\nInitializes the gRPCCURL object. This should be called once before making gRPC calls. There is no harm in calling this more than once (ie by different packages/dependencies). Typical usage looks like this:\n\ngrpc_init()\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001)\n\n# Make some gRPC calls \n\n# Shut down the global gRPC handle\ngrpc_shutdown()\n\nUnless specifying a gRPCCURL the global one provided by grpc_global_handle() is used. Each gRPCCURL state has its own connection pool and request semaphore, so sometimes you may want to manage your own like shown below:\n\ngrpc_myapp = gRPCCURL()\ngrpc_init(grpc_myapp)\n\nclient = TestService_TestRPC_Client(\"172.238.177.88\", 8001; grpc=grpc_myapp)\n\n# Make some gRPC calls \n\n# Only shuts down your gRPC handle\ngrpc_shutdown(grpc_myapp)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_shutdown-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_shutdown","text":"grpc_shutdown([grpc_curl::gRPCCURL])\n\nShuts down the gRPCCURL. This neatly cleans up all active connections and requests. Useful for calling during development with Revise. Unless specifying the gRPCCURL, the global one provided by grpc_global_handle() is shutdown.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_global_handle-Tuple{}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_global_handle","text":"grpc_global_handle()\n\nReturns the global gRPCCURL state which contains a libCURL multi handle. By default all gRPC clients use this multi in order to ensure that HTTP/2 multiplexing happens where possible.\n\n\n\n\n\n","category":"method"},{"location":"#RPC","page":"gRPCClient2.jl","title":"RPC","text":"","category":"section"},{"location":"#Unary","page":"gRPCClient2.jl","title":"Unary","text":"","category":"section"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return a gRPCRequest object without waiting for the response.  In order to wait on / retrieve the result once its ready, call grpc_async_await. This is ideal when you need to send many requests in parallel and waiting on each response before sending the next request would things down.\n\nusing gRPCClient2\n\ngrpc_init()\n\n# Include the generated bindings\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Create a client bound to a specific RPC\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\n# Make a syncronous request and get back a TestResponse\nresponse = grpc_sync_request(client, TestRequest(1, zeros(UInt64, 1)))\n@info response\n\n# Make some async requests and await their TestResponse\nrequests = Vector{gRPCRequest}()\nfor i in 1:10\n    push!(\n        requests, \n        grpc_async_request(client, TestRequest(1, zeros(UInt64, 1)))\n    )\nend\n\nfor request in requests\n    response = grpc_async_await(client, request)\n    @info response\nend\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, false, TResponse, false}, TRequest, Channel{gRPCAsyncChannelResponse{TResponse}}, Int64}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,false,TResponse,false}, request::TRequest, channel::Channel{gRPCAsyncChannelResponse{TResponse}}, index::Int64) where {TRequest<:Any,TResponse<:Any}\n\nInitiate an asynchronous gRPC request: send the request to the server and then immediately return. When the request is complete a background task will put the response in the provided channel. This has the advantage over the request / await patern in that you can handle responses immediately after they are recieved in any order.\n\nusing gRPCClient2\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\n# Connect to the test server\nclient = TestService_TestRPC_Client(\"localhost\", 8001)\n\nN = 10\n\nchannel = Channel{gRPCAsyncChannelResponse{TestResponse}}(N)\n\nfor (index, request) in enumerate([TestRequest(i, zeros(UInt64, i)) for i in 1:N])\n     grpc_async_request(client, request, channel, index)\nend\n\nfor i in 1:N\n    cr = take!(channel)\n    # Check if an exception was thrown, if so throw it here\n    !isnothing(cr.ex) && throw(cr.ex)\n\n    # If this does not hold true, then the requests and responses have gotten mixed up.\n    @assert length(cr.response.data) == cr.index\nend\n\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, false, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_await","text":"grpc_async_await(client::gRPCClient{TRequest,false,TResponse,false}, request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nWait for the request to complete and return the response when it is ready. Throws any exceptions that were encountered during handling of the request.\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_sync_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, false, TResponse, false}, TRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_sync_request","text":"grpc_sync_request(client::gRPCClient{TRequest,false,TResponse,false}, request::TRequest) where {TRequest<:Any,TResponse<:Any}\n\nDo a synchronous gRPC request: send the request and wait for the response before returning it.  Under the hood this just calls grpc_async_request and grpc_async_await\n\n\n\n\n\n","category":"method"},{"location":"#Streaming","page":"gRPCClient2.jl","title":"Streaming","text":"","category":"section"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, true, TResponse, false}, Channel{TRequest}}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,true,TResponse,false}, request::Channel{TRequest}) where {TRequest<:Any,TResponse<:Any}\n\nStart a requesting streaming gRPC request.\n\nusing gRPCClient2\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestClientStreamRPC_Client(\"localhost\", 8001)\nrequest_c = Channel{TestRequest}(16)\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\n\nreq = grpc_async_request(client, request_c)\n\n# Must close the request channel when done sending requests\nclose(request_c)\n\n# Get the response\ntest_response = grpc_async_await(client, req)\n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, false, TResponse, true}, TRequest, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,false,TResponse,true},request::TRequest,response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a response streaming gRPC request.\n\nusing gRPCClient2\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestServerStreamRPC_Client(\"localhost\", 8001)\n\nresponse_c = Channel{TestResponse}(16)\n\nreq = grpc_async_request(\n    client,\n    TestRequest(1, zeros(UInt64, 1)),\n    response_c,\n)\ntest_response = take!(response_c)\n\n# Raise any exceptions encountered during the request\ngrpc_async_await(req) \n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_request-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, true, TResponse, true}, Channel{TRequest}, Channel{TResponse}}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_request","text":"grpc_async_request(client::gRPCClient{TRequest,true,TResponse,true},request::Channel{TRequest},response::Channel{TResponse}) where {TRequest<:Any,TResponse<:Any}\n\nStart a bidirectional gRPC request.\n\nusing gRPCClient2\n\ngrpc_init()\ninclude(\"test/gen/test/test_pb.jl\")\n\nclient = TestService_TestBidirectionalStreamRPC_Client(\"localhost\", 8001)\n\nrequest_c = Channel{TestRequest}(16)\nresponse_c = Channel{TestResponse}(16)\n\nput!(request_c, TestRequest(1, zeros(UInt64, 1)))\nreq = grpc_async_request(client, request_c, response_c)\ntest_response = take!(response_c)\n\n# Must close the request channel when done sending requests\nclose(request_c)\n# Raise any exceptions encountered during the request\ngrpc_async_await(req) \n\n\n\n\n\n","category":"method"},{"location":"#gRPCClient2.grpc_async_await-Union{Tuple{TResponse}, Tuple{TRequest}, Tuple{gRPCClient{TRequest, true, TResponse, false}, gRPCRequest}} where {TRequest, TResponse}","page":"gRPCClient2.jl","title":"gRPCClient2.grpc_async_await","text":"grpc_async_await(client::gRPCClient{TRequest,true,TResponse,false},request::gRPCRequest) where {TRequest<:Any,TResponse<:Any}\n\nRaise any exceptions encountered during the streaming request.\n\n\n\n\n\n","category":"method"},{"location":"#Exceptions","page":"gRPCClient2.jl","title":"Exceptions","text":"","category":"section"},{"location":"#gRPCClient2.gRPCServiceCallException","page":"gRPCClient2.jl","title":"gRPCClient2.gRPCServiceCallException","text":"Exception type that is thrown when something goes wrong while calling an RPC. This can either be triggered by the servers response code or by the client when something fails.\n\nThis exception type has two fields:\n\ngrpc_status::Int - See here for an indepth explanation of each status.\nmessage::String\n\n\n\n\n\n","category":"type"}]
}
